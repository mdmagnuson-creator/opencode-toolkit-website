{
  "project": "Toolkit Website",
  "branchName": "feature/hybrid-changelog-sync",
  "description": "Implement a hybrid changelog model with build-time baseline data, runtime GitHub refresh, and safe fallback behavior.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Define hybrid architecture contract",
      "description": "As a maintainer, I want a clear hybrid source strategy so changelog freshness improves without introducing brittle behavior.",
      "acceptanceCriteria": [
        "Document baseline source (build-time manifest) and runtime refresh source (GitHub)",
        "Define precedence rules: runtime toolkit data overrides baseline toolkit data when successful",
        "Define fallback rules when runtime fetch is unavailable",
        "Typecheck passes",
        "Lint passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Hybrid architecture implemented in changelog-fetcher.ts and ChangelogClient.tsx. Baseline from build-time manifest, runtime from GitHub, with fallback to baseline on failure.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": false,
      "e2eScope": null,
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    },
    {
      "id": "US-002",
      "title": "Build runtime refresh fetcher for toolkit changelog",
      "description": "As a visitor, I want the page to refresh toolkit changelog data from GitHub so I can see updates soon after they land in ai-toolkit.",
      "acceptanceCriteria": [
        "Add runtime fetch utility for toolkit changelog entries from public GitHub source",
        "Validate and normalize external payload shape before merge",
        "Handle network failures safely without crashing UI",
        "Typecheck passes",
        "Lint passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Created /src/lib/changelog-fetcher.ts with fetchToolkitChangelog(), validateManifest(), and normalizeChangelog() functions. Fetches from GitHub raw URL with full error handling.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": false,
      "e2eScope": null,
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    },
    {
      "id": "US-003",
      "title": "Merge hybrid toolkit data with website entries",
      "description": "As a visitor, I want one combined timeline so I can see toolkit and website updates in a single chronological view.",
      "acceptanceCriteria": [
        "Merge selected toolkit changelog source (runtime if fresh, baseline otherwise) with websiteChangelog",
        "Keep source badges (toolkit, website) for each entry",
        "Merge by day and sort newest to oldest",
        "Typecheck passes",
        "Lint passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Added mergeChangelogs() function in /src/data/index.ts. ChangelogClient.tsx merges runtime toolkit data with website changelog, sorted by day newest-first.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": false,
      "e2eScope": null,
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    },
    {
      "id": "US-004",
      "title": "Add loading, stale, and fallback states",
      "description": "As a visitor, I want the changelog page to remain usable even if runtime fetch is slow or unavailable.",
      "acceptanceCriteria": [
        "Show a loading state while runtime changelog fetch resolves",
        "Show a fallback mode using baseline manifest + website changelog if runtime fetch fails",
        "Display brief freshness/error messaging when fallback is active",
        "Typecheck passes",
        "Lint passes",
        "Verify in browser",
        "Works in both light and dark mode"
      ],
      "priority": 4,
      "passes": true,
      "notes": "ChangelogClient.tsx implements loading spinner, fallback state with amber warning banner, and error messaging. Dark mode compatible with proper color classes.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": true,
      "e2eScope": "Changelog page shows loading, fallback, and freshness/error messaging without breaking layout",
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    },
    {
      "id": "US-005",
      "title": "Add TTL caching and explicit refresh control",
      "description": "As a maintainer, I want lightweight caching so we reduce repeated GitHub requests and avoid rate-limit pressure.",
      "acceptanceCriteria": [
        "Cache runtime toolkit payload in browser with 15-minute default TTL",
        "Respect cached data before issuing a new fetch when TTL is valid",
        "Add manual refresh action to force a fresh runtime fetch",
        "Typecheck passes",
        "Lint passes",
        "Verify in browser",
        "Works in both light and dark mode"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Implemented localStorage caching with 15-minute TTL in changelog-fetcher.ts. ChangelogClient.tsx has refresh button that calls forceRefresh parameter to bypass cache.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": true,
      "e2eScope": "Refresh control and cache behavior are observable and functional in changelog UI",
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    },
    {
      "id": "US-006",
      "title": "Instrument and validate hybrid sync behavior",
      "description": "As a maintainer, I want confidence that runtime sync works in production-like conditions.",
      "acceptanceCriteria": [
        "Log/track runtime fetch outcome categories (success, stale-cache, fallback, failure)",
        "Validate behavior with normal network, slow network, and failed network scenarios",
        "Confirm page remains readable and functional in all scenarios",
        "Typecheck passes",
        "Lint passes",
        "Verify in browser",
        "Works in both light and dark mode"
      ],
      "priority": 6,
      "passes": true,
      "notes": "changelog-fetcher.ts returns FetchOutcome with status categories (success, stale-cache, fallback, failure). Console logging for debugging. UI remains functional across all network states.",
      "documentationRequired": false,
      "documentationType": null,
      "relatedArticleSlugs": [],
      "e2eRequired": true,
      "e2eScope": "Changelog remains usable across success, slow, and failure network states",
      "marketingRequired": false,
      "marketingType": null,
      "relatedMarketingPages": [],
      "toolsRequired": false,
      "toolsType": null,
      "relatedToolNames": []
    }
  ]
}
